# AUTOGENERATED from:
# $ python stm_register_builder.py stm32lib/CMSIS/STM32WBxx/Include/stm32wb55xx.h


import uctypes
from micropython import const


class Register:
    def __init__(self, addr) -> None:
        if not hasattr(self.__class__, "__regs__"):
            # We have register definitions defined on Register subclasses, which are used
            # to create the uctypes.struct instances.
            # These attributes get in the way of reading the struct attrs though, so move
            # them to an class.__regs__ dict for referencing and delete from the class itself.
            __regs__ = {k: v for k, v in self.__class__.__dict__.items() if not k.startswith("_")}
            setattr(self.__class__, "__regs__", __regs__)
            for k in __regs__:
                delattr(self.__class__, k)

        self.__addr__ = addr

        descriptor = {
            k: (v | uctypes.UINT32) for k, v in self.__class__.__regs__.items()  # type: ignore
        }
        self.__struct__ = uctypes.struct(addr, descriptor)

    def __reg_addr__(self, register: str):
        return self.__addr__ + self.__regs__[register]

    def __repr__(self):
        return f"<{self.__class__.__name__} 0x{self.__addr__:x}>"

    def __dir__(self):
        return [k for k in self.__regs__]

    def __inspect__(self):
        print(self.__class__.__name__)
        struct = self.__struct__
        for k, v in sorted(self.__regs__.items(), key=lambda t: t[1]):
            val = getattr(struct, k)
            print(f"{k : 10} (0x{v:04x}):  0x{val:04x}")

    def __getattr__(self, __name: str):
        if __name.startswith("_"):
            raise AttributeError(__name)

        v = getattr(self.__struct__, __name)
        return v

    def __setattr__(self, __name: str, __value) -> None:
        if __name.startswith("_"):
            object.__setattr__(self, __name, __value)
        else:
            setattr(self.__struct__, __name, __value)




PERIPH_BASE = const(0x40000000)  # Peripheral base address
APB1PERIPH_BASE = const(PERIPH_BASE)
APB2PERIPH_BASE = const(PERIPH_BASE + 0x00010000)
TIM2_BASE = const(APB1PERIPH_BASE + 0x00000000)
LPTIM1_BASE = const(APB1PERIPH_BASE + 0x00007C00)
LPTIM2_BASE = const(APB1PERIPH_BASE + 0x00009400)
TIM1_BASE = const(APB2PERIPH_BASE + 0x00002C00)
DBGMCU_BASE = const(0xE0042000)


# Debug MCU
class DBGMCU_TypeDef(Register):
    IDCODE: int = 0x00  # /*!< MCU device ID code,             Address offset: 0x00 */
    CR: int = 0x04  # /*!< Debug MCU configuration register,      Address offset: 0x04 */
    # RESERVED1[13]: int = 0x38  # /*!< Reserved,                        0x08-0x38 */
    APB1FZR1: int = 0x3C  # /*!< Debug MCU CPU1 APB1 freeze register,     Address offset: 0x3C */
    C2APB1FZR1: int = 0x40  # /*!< Debug MCU CPU2 APB1 freeze register,     Address offset: 0x40 */
    APB1FZR2: int = 0x44  # /*!< Debug MCU CPU1 APB1 freeze register,     Address offset: 0x44 */
    C2APB1FZR2: int = 0x48  # /*!< Debug MCU CPU2 APB1 freeze register,     Address offset: 0x48 */
    APB2FZR: int = 0x4C  # /*!< Debug MCU CPU1 APB2 freeze register,     Address offset: 0x4C */
    C2APB2FZR: int = 0x50  # /*!< Debug MCU CPU2 APB2 freeze register,     Address offset: 0x50 */

# LPTIMER
class LPTIM_TypeDef(Register):
    ISR: int = 0x00  # /*!< LPTIM Interrupt and Status register,        Address offset: 0x00 */
    ICR: int = 0x04  # /*!< LPTIM Interrupt Clear register,           Address offset: 0x04 */
    IER: int = 0x08  # /*!< LPTIM Interrupt Enable register,          Address offset: 0x08 */
    CFGR: int = 0x0C  # /*!< LPTIM Configuration register,            Address offset: 0x0C */
    CR: int = 0x10  # /*!< LPTIM Control register,               Address offset: 0x10 */
    CMP: int = 0x14  # /*!< LPTIM Compare register,               Address offset: 0x14 */
    ARR: int = 0x18  # /*!< LPTIM Autoreload register,             Address offset: 0x18 */
    CNT: int = 0x1C  # /*!< LPTIM Counter register,               Address offset: 0x1C */
    OR: int = 0x20  # /*!< LPTIM Option register,               Address offset: 0x20 */

# TIM
class TIM_TypeDef(Register):
    CR1: int = 0x00  # /*!< TIM control register 1,          Address offset: 0x00 */
    CR2: int = 0x04  # /*!< TIM control register 2,          Address offset: 0x04 */
    SMCR: int = 0x08  # /*!< TIM slave mode control register,     Address offset: 0x08 */
    DIER: int = 0x0C  # /*!< TIM DMA/interrupt enable register,    Address offset: 0x0C */
    SR: int = 0x10  # /*!< TIM status register,           Address offset: 0x10 */
    EGR: int = 0x14  # /*!< TIM event generation register,      Address offset: 0x14 */
    CCMR1: int = 0x18  # /*!< TIM capture/compare mode register 1,   Address offset: 0x18 */
    CCMR2: int = 0x1C  # /*!< TIM capture/compare mode register 2,   Address offset: 0x1C */
    CCER: int = 0x20  # /*!< TIM capture/compare enable register,   Address offset: 0x20 */
    CNT: int = 0x24  # /*!< TIM counter register,           Address offset: 0x24 */
    PSC: int = 0x28  # /*!< TIM prescaler register,          Address offset: 0x28 */
    ARR: int = 0x2C  # /*!< TIM auto-reload register,         Address offset: 0x2C */
    RCR: int = 0x30  # /*!< TIM repetition counter register,     Address offset: 0x30 */
    CCR1: int = 0x34  # /*!< TIM capture/compare register 1,      Address offset: 0x34 */
    CCR2: int = 0x38  # /*!< TIM capture/compare register 2,      Address offset: 0x38 */
    CCR3: int = 0x3C  # /*!< TIM capture/compare register 3,      Address offset: 0x3C */
    CCR4: int = 0x40  # /*!< TIM capture/compare register 4,      Address offset: 0x40 */
    BDTR: int = 0x44  # /*!< TIM break and dead-time register,     Address offset: 0x44 */
    DCR: int = 0x48  # /*!< TIM DMA control register,         Address offset: 0x48 */
    DMAR: int = 0x4C  # /*!< TIM DMA address for full transfer,    Address offset: 0x4C */
    OR: int = 0x50  # /*!< TIM option register            Address offset: 0x50 */
    CCMR3: int = 0x54  # /*!< TIM capture/compare mode register 3,   Address offset: 0x54 */
    CCR5: int = 0x58  # /*!< TIM capture/compare register5,      Address offset: 0x58 */
    CCR6: int = 0x5C  # /*!< TIM capture/compare register6,      Address offset: 0x5C */
    AF1: int = 0x60  # /*!< TIM Alternate function option register 1, Address offset: 0x60 */
    AF2: int = 0x64  # /*!< TIM Alternate function option register 2, Address offset: 0x64 */

TIM2 = TIM_TypeDef(TIM2_BASE)
LPTIM1 = LPTIM_TypeDef(LPTIM1_BASE)
LPTIM2 = LPTIM_TypeDef(LPTIM2_BASE)
TIM1 = TIM_TypeDef(TIM1_BASE)
DBGMCU = DBGMCU_TypeDef(DBGMCU_BASE)


__dev_id = DBGMCU.IDCODE & 0xFFF
if __dev_id != 0x495:
    raise RuntimeError(f"_stm_registers.py was generated for stm32wb (0x495), running on {__dev_id}")
