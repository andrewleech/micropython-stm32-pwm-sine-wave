import re
from pathlib import Path
from collections import OrderedDict


def __register_file_generator(filename):
    """
    This function can be run from cpython with the stm hal cpu include
    for the target processor to generate the register definitions required.
    eg. micropython/lib/stm32lib/CMSIS/STM32WBxx/Include/stm32wb55xx.h
    """

    # Peripheral / registers we need are used in stm_dma_timer.py
    __desired__ = (Path(__file__).parent / "signal_gen" / "stm_dma_timer.py").read_text() + "DBGMCU_IDCODE"

    filename = Path(filename).resolve()
    cpu = filename.stem[0:7]

    stm32lib = Path(filename.parent / ".." / ".." / "..").resolve()
    hal_include = stm32lib / f"{cpu.upper()}xx_HAL_Driver" / "Inc"
    header_ll_dma = hal_include / f"{cpu}xx_ll_dma.h"
    header_ll_dmamux = hal_include / f"{cpu}xx_ll_dmamux.h"
    header_ll_system = hal_include / f"{cpu}xx_ll_system.h"
    if not header_ll_dma.exists():
        raise SystemExit(f"Can't find matching dma headers: {header_ll_dma}")

    system_header = header_ll_system.read_text()
    expected_dev_id = re.findall(r"the device ID is (0x[0-9a-fA-F]+)", system_header)[0]

    content = filename.read_text()
    content += header_ll_dma.read_text()
    content += header_ll_dmamux.read_text()

    output = Path(__file__).parent / "signal_gen" / f"_stm_registers.py"
    out_content = [
        f"# AUTOGENERATED from:",
        f"# $ python {Path(__file__).name} {filename.relative_to(stm32lib.parent)}",
        f"",
        f"from stm_dma_timer import Register, const",
        f"",
    ]
    out_elements = OrderedDict()

    # Parse #defines in the header files

    register_instances = OrderedDict()
    register_instances_content = ""
    defines = {}
    for line in re.findall(r"#define (\S+) +(.+)\n", content):
        name, details = line
        if "(" in name:
            # ignore macros
            continue

        if details.endswith("\\"):
            continue
        comment = ""
        for comments in re.findall(r"(/\*!?<?(.*?)\*/)", details):
            comment = "  # " + comments[1].strip()
            details = details.split("/*")[0]
            break

        value = details.strip()
        if not value:
            continue

        # Remove UL suffix from numbers
        value = re.sub(r"(0x[a-fA-F0-9]+)[UL]*", r"\1", value)
        value = re.sub(r"([0-9]+)[UL]*", r"\1", value)
        # Parse out any type casting
        if value.startswith("(") and value.endswith(")"):
            value = value[1:-1]

        # keep = False
        # if name in __desired__:
        #     if ptn in name:
        #         keep = True
        #         break
        # if not keep:
        #     continue

        # The headers have bitfields broken out into 3 lines. Optimise them when possible...
        if name.endswith("_Pos"):
            defines[name] = (value, comment)
            continue

        elif name.endswith("_Msk"):
            pos = name.replace("_Msk", "_Pos")
            if pos in value and pos in defines:
                pos_value, pos_comment = defines[pos]
                value = value.replace(pos, pos_value)
                comment += pos_comment
            defines[name] = (value, comment)
            continue

        for ptn in re.findall(r"(\S+_(Msk|Pos))", value):
            if ptn[0] in defines:
                ptn_value, ptn_comment = defines[ptn[0]]
                value = value.replace(ptn[0], ptn_value)
                comment += ptn_comment

        if "TypeDef *)" in value:
            for details in re.findall(r"\((\S+TypeDef) *\*\) (\S+)", value):
                value = f"{details[0]}({details[1]})"
                break
            if name in __desired__:
                register_instances[name] = f"{name} = {value}{comment}"
                register_instances_content += value
        else:
            out_elements[name] = f"{name} = const({value}){comment}"

    # Register TypeDef's
    # out_content.append("")

    registers = []

    registers_h = re.findall(
        r"((@brief (.+)\n *\*/\n)?typedef struct\n\{\n(.*uint32_t *\S+ *; */\*!<.*\*/\n\n?)+\} ?(\S+TypeDef);)",
        content,
    )

    for reg in registers_h:
        name = reg[4]
        fields = []
        i_off = 0
        for i, row in enumerate(re.findall("\n.*uint32_t *(\S+) *;( */\*!<(.*)\*/)?", reg[0])):
            field = row[0]
            if "[" in field:
                # Don't support arrays, just fix index
                i_off += int(field.split("[")[-1].split("]")[0]) - 1
                field = "# " + field
            if field.startswith("RESERVED"):
                field = "# " + field
            index = (i + i_off) * 4
            comment = row[1].strip().replace("  ", " ")
            fields.append((field, index, comment))

        title = reg[2] or name

        if name in __desired__ or name in register_instances_content:
            registers.extend(
                [
                    "",
                    f"# {title}",
                    f"class {name}(Register):",
                ]
                + [f"    {fn}: int = 0x{i:02X}  # {c}" for fn, i, c in fields]
            )

    keep = set()
    keep_content = ""
    last_keep_len = None
    while last_keep_len != len(keep):
        last_keep_len = len(keep)
        for name, val in out_elements.items():
            if name in __desired__ or name in register_instances_content or name in keep_content:
                keep.add(name)
                keep_content += val

    out_content.append("")

    for name, elem in out_elements.items():
        if name in keep:
            out_content.append(elem)

    out_content.append("")
    out_content.extend(registers)

    out_content.append("")
    out_content.extend(register_instances.values())

    out_content.append("")
    out_content.extend([
        f"",
        f"__dev_id = DBGMCU.IDCODE & 0xFFF",
        f"if __dev_id != {expected_dev_id}:",
        f'    raise RuntimeError(f"{output.name} was generated for {cpu} ({expected_dev_id}), running on {{__dev_id}}")',
        f"",
    ])

    Path(output).write_text("\n".join(out_content))
    print(f"Written: {output}")


if __name__ == "__main__":
    import sys

    __register_file_generator(sys.argv[1])
    sys.exit()
